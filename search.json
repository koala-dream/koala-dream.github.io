[{"title":"I2C基础知识","url":"/2026/01/26/2026-1-26-I2C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"简述I2C总线的基本原理。 (提示：两线制、同步、半双工、多主多从、地址寻址)\n\n(1)     IIC使用SCL和SDA两根线，SCL用于同步，SDA负责数据传输\n(2)    是半双工机制（主从机之间不能同时传输数据。）\n(3)    IIC是多主多从的协议\n(4)    地址寻址可以要么7位地址，要么10位地址\n🔴 重要内容\n\n为什么I2C总线需要上拉电阻？其阻值如何选择？(1)    因为需要实现多从机的机制，IIC的引脚需要使用开漏模式挂载到IIC总线上，开漏模式下的高电平由上拉电阻实现。如果不使用开漏输出模式，当主机访问从机1时，从机1拉低总线电平，而从机2会输出高电平，表示不应答，但是这样的话，会使得总线短路。开漏模式下，从机2释放总线（输出高阻态），不会影响到从机1的拉低，因为上拉电阻的存在，总线不会短路。\n(2)    根据IIC协议的速度需求选择阻值\nstruct power_supply_config &#123;    struct device_node *of_node;  // 设备节点    struct fwnode_handle *fwnode; // fwnode 节点    void *drv_data; // 私有数据    const struct attribute_group **attr_grp; // 私有的属性节点    char **supplied_to;  // 一个字符串数组, 保存了该 psy 向下一级供电的 psy 列表. 组织 psy 之间的级联方向.    size_t num_supplicants;    ANDROID_KABI_RESERVE(1);&#125;;\n\n\n\n详细描述I2C通信的时序：起始条件、停止条件、数据有效性及应答机制。(1)    起始信号：当SCL处于高电平时，SDA给出从高到低的下降沿电平\n(2)    停止信号：当SCL处于高电平时，SDA给出从低到高的上升沿电平\n(3)    当SCL处于低电平时，可以改变SDA的值，SCL处于高电平时，可以进行采样\n(4)    在接收完一帧数据后，从机&#x2F;主机应当选择拉低SDA总线进行应答，如果选择不应答，释放总线。\n什么是重复起始条件？它有什么作用？(1)    在不结束一次通讯的情况下，再次发起起始信号，但是这个重复起始信号的发起和起始信号不完全相同，因为在主机发送完一帧数据，从机应答后，SDA处于低电平状态，主机将SCL从高电平拉到低电平。这时，需要绕过终止信号，所以SCL需要先被拉低，然后拉高SDA，之后再拉高SCL（终于绕过终止信号，恢复到初始状态了，两个都为高电平），这个时候再发起始信号，就是一次完整的重复起始条件了。\n(2)    可以进行由写指令到读指令的转化。\nI2C支持哪些速率模式？实际选择时考虑哪些因素？I2C的地址有几位？7位地址的可用范围是多少？什么是保留地址？(1)    7位或者10位\n(2)    理论上是0-127，总共是128个地址。\n(3)    是一些特殊功能的地址，比如说复位功能，广播功能。\n为什么I2C要求使用开漏输出，而不能用推挽输出？ (需理解总线冲突、短路风险、多主机仲裁)I2C总线上最多能连接多少个设备？实际限制是什么？ (提示：地址空间限制 vs 总线电容负载限制)解释什么是“时钟拉伸”。它是如何工作的？有什么作用？I2C总线的最大传输距离受哪些因素影响？如何优化？I2C如何实现多主机通信？详细解释总线仲裁和时钟同步机制。如果总线上有两个从设备地址相同，会发生什么？如何解决？主机发送地址0x50和主机发送地址0x52同时发起通信，谁将赢得仲裁？请按位分析过程。比较I2C与SPI协议的优缺点。在什么场景下优先选择I2C？列举I2C通信中常见的故障及解决方法（如总线死锁、ACK丢失、时序问题等）。如果发现I2C通信不稳定，你的调试步骤是什么？会使用什么工具？ (如示波器、逻辑分析仪)描述一次你调试I2C总线问题的实际经历，包括问题现象、分析思路和最终解决方案。 (这是展现你工程能力的绝佳机会)","categories":["Linux I2C驱动"],"tags":["I2C"]},{"title":"input子系统","url":"/2026/02/09/2026-2-9-input%E5%AD%90%E7%B3%BB%E7%BB%9F/","content":"输入子系统-input关键数据结构struct input_dev &#123;\tconst char *name;\t\t\t\t\t// 设备名字（需要）\tconst char *phys;\t\t\t\t\t// 设备的物理路径名字？（不重要）\tconst char *uniq;\t\t\t\t\t// 设备的唯一标识符（不重要）\tstruct input_id id;\t\t\t\t\t// 设备ID（不重要）\tunsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];\t// 设备属性位图（比较复杂）    \t/* 表示这个设备能够上报哪些类型的事件，使用前需要提前配置好 */\tunsigned long evbit[BITS_TO_LONGS(EV_CNT)];\t\t// 事件类型位图（重要）\tunsigned long keybit[BITS_TO_LONGS(KEY_CNT)];\t\t// 事件码位图（重要）\tunsigned long relbit[BITS_TO_LONGS(REL_CNT)];\t\t// 相对坐标事件码位图（如何使用？）\tunsigned long absbit[BITS_TO_LONGS(ABS_CNT)];\t\t// 绝对坐标事件码（重要）\tunsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];\t\t// 杂项事件位图（如何使用？）\tunsigned long ledbit[BITS_TO_LONGS(LED_CNT)];\t\t// LED指示灯位图（如何使用？）\tunsigned long sndbit[BITS_TO_LONGS(SND_CNT)];\t\t// 声音事件位图（如何使用？）\tunsigned long ffbit[BITS_TO_LONGS(FF_CNT)];\t\t// 力反馈事件位图（游戏手柄震动？）\tunsigned long swbit[BITS_TO_LONGS(SW_CNT)];\t\t// 开关事件位图（重要）        struct input_absinfo *absinfo;\t\t\t\t// 绝对坐标事件的信息配置        struct input_mt *mt;\t\t\t\t\t// 用于多点触摸管理        struct device dev;\t\t\t\t\t// 表示input框架所绑定的物理输入设备    \tunsigned long key[BITS_TO_LONGS(KEY_CNT)];\t\t// 按键状态位图，描述按键是否按下\tunsigned long led[BITS_TO_LONGS(LED_CNT)];\t\t// 同理\tunsigned long snd[BITS_TO_LONGS(SND_CNT)];\t\t// 同理\tunsigned long sw[BITS_TO_LONGS(SW_CNT)];\t\t// 同理    \t/* 内核自动管理，APP使用 */\tint (*open)(struct input_dev *dev);\tvoid (*close)(struct input_dev *dev);\tint (*flush)(struct input_dev *dev, struct file *file);\tint (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);    /*********************以下不是特别重要，大部分属于内核自动管理*******************/    .......&#125;;\n\n","categories":["Linux I2C驱动"],"tags":["I2C"]},{"title":"GT911在RK3568上的调试记录","url":"/2026/02/09/2026-2-9-GT911%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/","content":"GT911重要寄存器控制寄存器：0x8040\n配置寄存器（组）：0x8047-0x8100\n状态寄存器：0x814E\n坐标寄存器（组）：0x8150-0x8177\n\n\n硬件设施准备通过命令行输入 i2cdetect -y 1 ，可以检测i2c1总线下所有设备的设备地址\n鲁班猫2上触摸屏接口\n中断引脚是GPIO0_B5\n复位引脚是GPIO0_B6\n\n对GT911的操作方法\n读操作时序图，高位先行，低位在后\n\n\n\n写i2c通信框架，能够读到GT911芯片的ID号（需要参考手册，看看ID号在哪个寄存器里）\n\n坐标寄存器中含有Product ID信息，读出来很有可能是“911”\n\n\n确认中断发生的方式（查询手册）\n\nGT911有两个地址可选，以下是把地址设置为0x14的方法，对应的8位地址是0x28\n\n\n以下是设置地址为0x5D的方法，本次调试只选0x14\n\n问题\ng_GT911_dev.reset_gpio &#x3D; gpiod_get_optional(&amp;client-&gt;dev, “reset”, GPIOD_OUT_LOW);申请失败，返回的是NULL，设备树中已经指定reset-gpios &#x3D; &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_HIGH&gt;;发现不是问题，是因为我调用了两次 gpiod_get_optional(&amp;client-&gt;dev, “reset”, 0);导致的哈哈\n\n怎么查看某一个引脚被复位成了什么功能呢？\n\n方法1：查看GPIO的复用功能（mux function）\ncat /sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/pinmux-pins\n\n方法2：查看gpio的label还有功能\ncat /sys/kernel/debug/gpio   \n\n方法3：查看i2c设备中，0x5d这个设备是绑定到哪个驱动程序上了\ncat /sys/bus/i2c/devices/1-0014/uevent 2&gt;/dev/null \n\n\n为什么我一在设备树中添加 irq-gpios   &#x3D; &lt;&amp;gpio0 RK_PB5 GPIO_ACTIVE_HIGH&gt;;，就无法进行probe函数了？无法和驱动进行匹配​        添加这两个都不会有问题\n\n​\t\t\tinterrupt-parent &#x3D; &lt;&amp;gpio0&gt;;​\t\t\tinterrupts &#x3D; ;\n\n设备树中，添加了irq-gpios 结点后，只能使用reg为0x5d，0x14用不了\n设为0x5d之后，只能使用irq-gpios   &#x3D; &lt;&amp;gpio0 RK_PB5 GPIO_ACTIVE_LOW&gt;;才能与我的驱动程序匹配，irq-gpios   &#x3D; &lt;&amp;gpio0 RK_PB5 GPIO_ACTIVE_HIGH&gt;;使用后就无法使用调用probe函数，很奇怪。。。\n以上奇奇怪怪的问题\n都是由于我自己写的设备树，匹配上了内核的驱动程序goodix.c（但是，我的compatible字符串和内核驱动程序的compatible字符串并不一样，逗号前面的内容不一样，但是逗号后面的内容都是gt911）\n（第三个问题：因为内核的gt911驱动程序接管了这个设备树，并且顺利地初始化了，导致我自己的驱动加载后，无法与设备树结点匹配）\n（第四个问题：是因为内核驱动程序，可以根据reg属性，配置gt911的地址，而且GPIO_ACTIVE_HIGH和LOW设置的不正确，也会有影响，影响驱动设置gt911地址过程）\n（第五个问题：因为如果设为LOW，在内核gt911驱动程序想要设置gt911的设备地址时，高低电平有误，然后无法设置，导致probe函数直接返回了，probe函数错误返回，就会导致与之匹配的设备树结点被释放，被释放之后，我的驱动程序就能被加载了，是这样一个过程）\n\n\n\n\n\n\n\n\n问题解决\n\n是因为iic总线匹配原则，同意只匹配逗号之后的字符串\n线索：我去内核看了一下，发现这里对逗号进行了操作，就是把逗号后面的字符串，当成这个i2c设备的名字了\n\n这个是i2c最外层的匹配函数，框起来的那个本来就是用来匹配全部字符串的\n\ni2c总线相比最普通的那个platform平台总线，多了这个名字匹配\n\n\n","categories":["Linux I2C驱动"],"tags":["I2C"]},{"title":"USB基础知识","url":"/2026/02/05/2026-2-8-usb%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"设备枚举阶段-usb设备插入电脑后会做的事情\n\n\n当一个usb设备，比如说u盘，插到Linux板子里后，它的地址会被强制配置成0，pc不知道这个设备的具体地址，就会去0地址处寻找，又因为整个usb链路上只有这个新加入的usb设备地址是0，所以就可以以此访问它\n\n通过对0地址的配置，读取，pc会为这个新加入的设备分配一个id号（每一个usb设备有一个id号，范围是1-127）\n\n这个被分配出来的id号，就是令牌包、数据包里的7为地址！系统通过这个地址寻找到设备！\n\n\n具体过程如下：USB设备插入板卡后，Linux系统会做的事情\nUSB接口两根线电平发生变换，会被内核usb控制器驱动程序感知到，在hub_thread中去读取设备描述符，配置描述符\n\n通过读取到的设备描述符，配置描述符，usb控制器驱动程序就知道这个设备是什么设备\n\n系统会根据之前获得的 “三要素”（类代码、厂商ID、产品ID），去匹配被编译进内核的驱动程序\n\n匹配到驱动后，在probe函数里可能会去做各种事情，比如说注册进input子系统，或者作为块设备（u盘）注册，注册使用接口\n\n\n","categories":["Linux USB驱动"],"tags":["USB"]}]